#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     irSeeker,             sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftBack,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rightBack,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     scoop,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftFront,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     rightFront,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "library.c"
#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment 4.X\Sample Programs\NXT\3rdPartyDriverLibrary\include\hitechnic-irseeker-v2.h"

// Global variables
int ir[6];

// Check whether we arrived at the IR beacon
bool hasArrived(void)
{
	const int arrivedThreshold = 105;
	for (int i = 1; i <= 5; i++)
	{
		if (ir[i] > arrivedThreshold) return true;
	}
	return false;
}

task main()
{

	const int maxSpeed = 60;

	bool wentForwardAlready = false;

	int lastLeft = 1;

	setLeft(maxSpeed);
	setRight(maxSpeed);
	wait1Msec(1500);
	setLeft(0);
	setRight(0);

	while(true)
	{

		if (!hasArrived())
		{

			HTIRS2readAllACStrength(irSeeker, ir[1], ir[2], ir[3], ir[4], ir[5]);

			int direction = HTIRS2readACDir(irSeeker);

			// These variables that are used only once don't exist, because RobotC can't hang
			if (direction == 0)
			{
				if (!wentForwardAlready)
				{
					setLeft(maxSpeed);
					setRight(maxSpeed);
					wait1Msec(1000);
					wentForwardAlready = true;
				}
				else
				{
					setLeft(lastLeft * maxSpeed);
					setRight(-1 * lastLeft * maxSpeed);
				}
			}
			else
			{
				wentForwardAlready = false;

				if (direction < 5)
				{
					setLeft(maxSpeed * -1);
					setRight(maxSpeed * 1);
					lastLeft = -1;
				}
				else if (direction > 5)
				{
					setLeft(maxSpeed * 1);
					setRight(maxSpeed * -1);
					lastLeft = 1;
				}
				else if (direction == 5)
				{
					setLeft(maxSpeed);
					setRight(maxSpeed);
					clearTimer(T1);
					while (!hasArrived() && time1[T1] < 3000)	{}
				}
			}
		}

		if (hasArrived())
		{
			setLeft(0);
			setRight(0);
			liftHeight(133);
			motor[scoop] = -87;
			const int ballSpittingOutTime = 750;
			wait1Msec(ballSpittingOutTime);
			liftHeight(-133);
		}

	}

}
